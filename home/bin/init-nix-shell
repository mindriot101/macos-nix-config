#!/usr/bin/env nix-shell
#!nix-shell -i python3.11 -p python311
# vim: ft=python

"""
Create a shell.nix with default settings in the current directory, and set the .envrc file to "use nix"
"""

from __future__ import annotations
import argparse
import enum
import logging
from typing import Protocol
from pathlib import Path
import sys

logging.basicConfig(level=logging.WARNING)
LOG = logging.getLogger(__name__)


class Preset(enum.Enum):
    rust = "rust"
    python = "python"


SHELL_NIX_TEMPLATE = """{ pkgs ? import <nixpkgs> { } }:
with pkgs;
mkShell {
  packages = [
  ];
}
"""

RUST_SHELL_NIX_TEMPLATE = """{ pkgs ? import <nixpkgs> { } }:
with pkgs;
mkShell rec {
  packages = [
    rustc
    cargo
    rustfmt
    rust-analyzer
  ] ++ lib.optionals stdenv.isDarwin [
    libiconv
  ];
  RUST_SRC_PATH = "${rustPlatform.rustLibSrc}";
  LD_LIBRARY_PATH = lib.makeLibraryPath packages;
}
"""

PYTHON_SHELL_NIX_TEMPLATE = """{ pkgs ? import <nixpkgs> { } }:
with pkgs;
mkShell {
  packages = [
    python3
    python3Packages.venvShellHook
  ];

  venvDir = ".venv";

  postVenvCreation = ''
    python -m pip install pip-tools
  '';
}
"""


def init_shell_nix(path: Path, content: str = SHELL_NIX_TEMPLATE):
    with path.open("w") as outfile:
        print(content, file=outfile)


def init_envrc(path: Path):
    with path.open("w") as outfile:
        print("use nix", file=outfile)


class Initialise(Protocol):
    def __call__(self, root: Path, force: bool):
        ...


def generic_init_dir(root: Path, force: bool):
    LOG.debug("initialising generic layout")
    shell_nix_path = root.joinpath("shell.nix")
    envrc_path = root.joinpath(".envrc")

    if shell_nix_path.is_file() and not force:
        raise ValueError(f"file exists at {shell_nix_path}")

    if envrc_path.is_file() and not force:
        raise ValueError(f"file exists at {envrc_path}")

    init_shell_nix(shell_nix_path)
    init_envrc(envrc_path)


def initialise_rust_project(root: Path, force: bool):
    LOG.debug("initialising rust project")
    shell_nix_path = root.joinpath("shell.nix")
    envrc_path = root.joinpath(".envrc")

    if shell_nix_path.is_file() and not force:
        raise ValueError(f"file exists at {shell_nix_path}")

    if envrc_path.is_file() and not force:
        raise ValueError(f"file exists at {envrc_path}")

    init_shell_nix(shell_nix_path, content=RUST_SHELL_NIX_TEMPLATE)
    init_envrc(envrc_path)


def initialise_python_project(root: Path, force: bool):
    LOG.debug("initialising python project")
    shell_nix_path = root.joinpath("shell.nix")
    envrc_path = root.joinpath(".envrc")

    if shell_nix_path.is_file() and not force:
        raise ValueError(f"file exists at {shell_nix_path}")

    if envrc_path.is_file() and not force:
        raise ValueError(f"file exists at {envrc_path}")

    init_shell_nix(shell_nix_path, content=PYTHON_SHELL_NIX_TEMPLATE)
    init_envrc(envrc_path)


INITIALISERS: dict[Preset | None, Initialise] = {
    Preset.rust: initialise_rust_project,
    Preset.python: initialise_python_project,
}


def init_dir(root: Path, preset: Preset | None, force: bool = False):
    LOG.info(f"initialising {root}")

    root.mkdir(exist_ok=True, parents=True)
    initialiser = INITIALISERS.get(preset, generic_init_dir)
    initialiser(root, force)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-p",
        "--preset",
        required=False,
        type=Preset,
    )
    parser.add_argument("-v", "--verbose", action="store_true", default=False)
    parser.add_argument("-r", "--root-dir", required=False, default=Path.cwd(), type=Path)
    parser.add_argument("-f", "--force", action="store_true", default=False)
    args = parser.parse_args()

    if args.verbose:
        LOG.setLevel(logging.DEBUG)

    try:
        init_dir(args.root_dir.resolve(), args.preset, args.force)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        raise SystemExit(1)
